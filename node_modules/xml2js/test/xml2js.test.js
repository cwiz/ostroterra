(function() {
  var assert, fileName, fs, path, skeleton, util, validator, xml2js;
  xml2js = require('../lib/xml2js');
  fs = require('fs');
  util = require('util');
  assert = require('assert');
  path = require('path');
  fileName = path.join(__dirname, '/fixtures/sample.xml');
  skeleton = function(options, checks) {
    return function(test) {
      var x2js, xmlString;
      xmlString = options != null ? options.__xmlString : void 0;
      if (options != null) {
        delete options.__xmlString;
      }
      x2js = new xml2js.Parser(options);
      x2js.addListener('end', function(r) {
        checks(r);
        return test.finish();
      });
      if (!xmlString) {
        return fs.readFile(fileName, function(err, data) {
          return x2js.parseString(data);
        });
      } else {
        return x2js.parseString(xmlString);
      }
    };
  };
  /*
  The `validator` function validates the value at the XPath. It also transforms the value
  if necessary to conform to the schema or other validation information being used. If there
  is an existing value at this path it is supplied in `currentValue` (e.g. this is the second or
  later item in an array).
  If the validation fails it should throw a `ValidationError`.
  */
  validator = function(xpath, currentValue, newValue) {
    if (xpath === '/sample/validatortest/numbertest') {
      return Number(newValue);
    } else if (xpath === '/sample/arraytest' || xpath === '/sample/validatortest/emptyarray' || xpath === '/sample/validatortest/oneitemarray') {
      if (!('item' in newValue)) {
        return {
          'item': []
        };
      }
    } else if (xpath === '/sample/arraytest/item' || xpath === '/sample/validatortest/emptyarray/item' || xpath === '/sample/validatortest/oneitemarray/item') {
      if (!currentValue) {
        return [newValue];
      }
    } else if (xpath === '/validationerror') {
      throw new xml2js.ValidationError("Validation error!");
    }
    return newValue;
  };
  module.exports = {
    'test parse with defaults': skeleton(void 0, function(r) {
      console.log('Result object: ' + util.inspect(r, false, 10));
      assert.equal(r['chartest']['@']['desc'], 'Test for CHARs');
      assert.equal(r['chartest']['#'], 'Character data here!');
      assert.equal(r['cdatatest']['@']['desc'], 'Test for CDATA');
      assert.equal(r['cdatatest']['@']['misc'], 'true');
      assert.equal(r['cdatatest']['#'], 'CDATA here!');
      assert.equal(r['nochartest']['@']['desc'], 'No data');
      assert.equal(r['nochartest']['@']['misc'], 'false');
      assert.equal(r['listtest']['item'][0]['#'], 'This is character data!');
      assert.equal(r['listtest']['item'][0]['subitem'][0], 'Foo(1)');
      assert.equal(r['listtest']['item'][0]['subitem'][1], 'Foo(2)');
      assert.equal(r['listtest']['item'][0]['subitem'][2], 'Foo(3)');
      assert.equal(r['listtest']['item'][0]['subitem'][3], 'Foo(4)');
      assert.equal(r['listtest']['item'][1], 'Qux.');
      return assert.equal(r['listtest']['item'][2], 'Quux.');
    }),
    'test parse with explicitCharkey': skeleton({
      explicitCharkey: true
    }, function(r) {
      assert.equal(r['chartest']['@']['desc'], 'Test for CHARs');
      assert.equal(r['chartest']['#'], 'Character data here!');
      assert.equal(r['cdatatest']['@']['desc'], 'Test for CDATA');
      assert.equal(r['cdatatest']['@']['misc'], 'true');
      assert.equal(r['cdatatest']['#'], 'CDATA here!');
      assert.equal(r['nochartest']['@']['desc'], 'No data');
      assert.equal(r['nochartest']['@']['misc'], 'false');
      assert.equal(r['listtest']['item'][0]['#'], 'This is character data!');
      assert.equal(r['listtest']['item'][0]['subitem'][0]['#'], 'Foo(1)');
      assert.equal(r['listtest']['item'][0]['subitem'][1]['#'], 'Foo(2)');
      assert.equal(r['listtest']['item'][0]['subitem'][2]['#'], 'Foo(3)');
      assert.equal(r['listtest']['item'][0]['subitem'][3]['#'], 'Foo(4)');
      assert.equal(r['listtest']['item'][1]['#'], 'Qux.');
      return assert.equal(r['listtest']['item'][2]['#'], 'Quux.');
    }),
    'test parse with mergeAttrs': skeleton({
      mergeAttrs: true
    }, function(r) {
      console.log('Result object: ' + util.inspect(r, false, 10));
      assert.equal(r['chartest']['desc'], 'Test for CHARs');
      assert.equal(r['chartest']['#'], 'Character data here!');
      assert.equal(r['cdatatest']['desc'], 'Test for CDATA');
      assert.equal(r['cdatatest']['misc'], 'true');
      assert.equal(r['cdatatest']['#'], 'CDATA here!');
      assert.equal(r['nochartest']['desc'], 'No data');
      assert.equal(r['nochartest']['misc'], 'false');
      assert.equal(r['listtest']['item'][0]['#'], 'This is character data!');
      assert.equal(r['listtest']['item'][0]['subitem'][0], 'Foo(1)');
      assert.equal(r['listtest']['item'][0]['subitem'][1], 'Foo(2)');
      assert.equal(r['listtest']['item'][0]['subitem'][2], 'Foo(3)');
      assert.equal(r['listtest']['item'][0]['subitem'][3], 'Foo(4)');
      assert.equal(r['listtest']['item'][1], 'Qux.');
      return assert.equal(r['listtest']['item'][2], 'Quux.');
    }),
    'test default text handling': skeleton(void 0, function(r) {
      return assert.equal(r['whitespacetest']['#'], 'Line One Line Two');
    }),
    'test disable trimming': skeleton({
      trim: false
    }, function(r) {
      return assert.equal(r['whitespacetest']['#'], 'Line One Line Two');
    }),
    'test disable normalize': skeleton({
      normalize: false
    }, function(r) {
      return assert.equal(r['whitespacetest']['#'], 'Line One\n        Line Two');
    }),
    'test disable normalize and trim': skeleton({
      normalize: false,
      trim: false
    }, function(r) {
      return assert.equal(r['whitespacetest']['#'], '\n        Line One\n        Line Two\n    ');
    }),
    'test default root node elimination': skeleton({
      __xmlString: '<root></root>'
    }, function(r) {
      return assert.deepEqual(r, {});
    }),
    'test disabled root node elimination': skeleton({
      __xmlString: '<root></root>',
      explicitRoot: true
    }, function(r) {
      return assert.deepEqual(r, {
        root: {}
      });
    }),
    'test default empty tag result': skeleton(void 0, function(r) {
      return assert.deepEqual(r['emptytest'], {});
    }),
    'test empty tag result specified null': skeleton({
      emptyTag: null
    }, function(r) {
      return assert.equal(r['emptytest'], null);
    }),
    'test empty string result specified null': skeleton({
      __xmlString: ' '
    }, function(r) {
      return assert.equal(r, null);
    }),
    'test parse with custom char and attribute object keys': skeleton({
      attrkey: 'attrobj',
      charkey: 'charobj'
    }, function(r) {
      assert.equal(r['chartest']['attrobj']['desc'], 'Test for CHARs');
      assert.equal(r['chartest']['charobj'], 'Character data here!');
      assert.equal(r['cdatatest']['attrobj']['desc'], 'Test for CDATA');
      assert.equal(r['cdatatest']['attrobj']['misc'], 'true');
      assert.equal(r['cdatatest']['charobj'], 'CDATA here!');
      assert.equal(r['nochartest']['attrobj']['desc'], 'No data');
      return assert.equal(r['nochartest']['attrobj']['misc'], 'false');
    }),
    'test child node without explicitArray': skeleton({
      explicitArray: false
    }, function(r) {
      assert.equal(r['arraytest']['item'][0]['subitem'], 'Baz.');
      assert.equal(r['arraytest']['item'][1]['subitem'][0], 'Foo.');
      return assert.equal(r['arraytest']['item'][1]['subitem'][1], 'Bar.');
    }),
    'test child node with explicitArray': skeleton({
      explicitArray: true
    }, function(r) {
      assert.equal(r['arraytest'][0]['item'][0]['subitem'][0], 'Baz.');
      assert.equal(r['arraytest'][0]['item'][1]['subitem'][0], 'Foo.');
      return assert.equal(r['arraytest'][0]['item'][1]['subitem'][1], 'Bar.');
    }),
    'test ignore attributes': skeleton({
      ignoreAttrs: true
    }, function(r) {
      assert.equal(r['chartest'], 'Character data here!');
      assert.equal(r['cdatatest'], 'CDATA here!');
      assert.deepEqual(r['nochartest'], {});
      assert.equal(r['listtest']['item'][0]['#'], 'This is character data!');
      assert.equal(r['listtest']['item'][0]['subitem'][0], 'Foo(1)');
      assert.equal(r['listtest']['item'][0]['subitem'][1], 'Foo(2)');
      assert.equal(r['listtest']['item'][0]['subitem'][2], 'Foo(3)');
      assert.equal(r['listtest']['item'][0]['subitem'][3], 'Foo(4)');
      assert.equal(r['listtest']['item'][1], 'Qux.');
      return assert.equal(r['listtest']['item'][2], 'Quux.');
    }),
    'test simple callback mode': function(test) {
      var x2js;
      x2js = new xml2js.Parser();
      return fs.readFile(fileName, function(err, data) {
        assert.equal(err, null);
        return x2js.parseString(data, function(err, r) {
          assert.equal(err, null);
          assert.equal(r['chartest']['#'], 'Character data here!');
          return test.finish();
        });
      });
    },
    'test double parse': function(test) {
      var x2js;
      x2js = new xml2js.Parser();
      return fs.readFile(fileName, function(err, data) {
        assert.equal(err, null);
        return x2js.parseString(data, function(err, r) {
          assert.equal(err, null);
          assert.equal(r['chartest']['#'], 'Character data here!');
          return x2js.parseString(data, function(err, r) {
            assert.equal(err, null);
            assert.equal(r['chartest']['#'], 'Character data here!');
            return test.finish();
          });
        });
      });
    },
    'test validator': skeleton({
      validator: validator
    }, function(r) {
      assert.equal(typeof r['validatortest']['stringtest'], 'string');
      assert.equal(typeof r['validatortest']['numbertest'], 'number');
      assert.ok(r['validatortest']['emptyarray']['item'] instanceof Array);
      assert.equal(r['validatortest']['emptyarray']['item'].length, 0);
      assert.ok(r['validatortest']['oneitemarray']['item'] instanceof Array);
      assert.equal(r['validatortest']['oneitemarray']['item'].length, 1);
      assert.equal(r['validatortest']['oneitemarray']['item'], 'Bar.');
      assert.ok(r['arraytest']['item'] instanceof Array);
      assert.equal(r['arraytest']['item'].length, 2);
      assert.equal(r['arraytest']['item'][0]['subitem'], 'Baz.');
      assert.equal(r['arraytest']['item'][1]['subitem'][0], 'Foo.');
      return assert.equal(r['arraytest']['item'][1]['subitem'][1], 'Bar.');
    }),
    'test validation error': function(test) {
      var x2js;
      x2js = new xml2js.Parser({
        validator: validator
      });
      return x2js.parseString('<validationerror/>', function(err, r) {
        assert.equal(err, 'Validation error!');
        return test.finish();
      });
    }
  };
}).call(this);
